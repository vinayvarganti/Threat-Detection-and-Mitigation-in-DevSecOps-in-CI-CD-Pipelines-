import numpy as np
import pandas as pd
from datetime import datetime
import logging

logger = logging.getLogger(__name__)

class VulnerabilityAnalyzer:
    def __init__(self):
        self.severity_weights = {
            'critical': 10.0,
            'high': 7.5,
            'medium': 5.0,
            'low': 2.5,
            'info': 1.0
        }
        
        self.category_weights = {
            'injection': 1.2,
            'broken_authentication': 1.1,
            'sensitive_data_exposure': 1.0,
            'xml_external_entities': 0.9,
            'broken_access_control': 1.1,
            'security_misconfiguration': 0.8,
            'cross_site_scripting': 1.0,
            'insecure_deserialization': 1.0,
            'known_vulnerabilities': 0.9,
            'insufficient_logging': 0.7
        }
    
    def analyze(self, vulnerabilities, project_context):
        """Analyze vulnerabilities and provide risk assessment"""
        try:
            if not vulnerabilities:
                return {
                    'total_vulnerabilities': 0,
                    'risk_score': 0.0,
                    'severity_breakdown': {},
                    'category_analysis': {},
                    'recommendations': [],
                    'priority_vulnerabilities': []
                }
            
            # Convert to DataFrame for analysis
            df = pd.DataFrame(vulnerabilities)
            
            # Calculate severity breakdown
            severity_breakdown = self._calculate_severity_breakdown(df)
            
            # Calculate category analysis
            category_analysis = self._analyze_categories(df)
            
            # Calculate overall risk score
            risk_score = self._calculate_risk_score(df, project_context)
            
            # Identify priority vulnerabilities
            priority_vulns = self._identify_priority_vulnerabilities(df)
            
            # Generate recommendations
            recommendations = self._generate_recommendations(df, project_context)
            
            return {
                'total_vulnerabilities': len(vulnerabilities),
                'risk_score': risk_score,
                'severity_breakdown': severity_breakdown,
                'category_analysis': category_analysis,
                'recommendations': recommendations,
                'priority_vulnerabilities': priority_vulns,
                'analysis_timestamp': datetime.utcnow().isoformat()
            }
            
        except Exception as e:
            logger.error(f"Vulnerability analysis failed: {str(e)}")
            raise
    
    def _calculate_severity_breakdown(self, df):
        """Calculate breakdown by severity"""
        if 'severity' not in df.columns:
            return {}
        
        severity_counts = df['severity'].value_counts().to_dict()
        total = len(df)
        
        breakdown = {}
        for severity in ['critical', 'high', 'medium', 'low', 'info']:
            count = severity_counts.get(severity, 0)
            breakdown[severity] = {
                'count': count,
                'percentage': (count / total * 100) if total > 0 else 0
            }
        
        return breakdown
    
    def _analyze_categories(self, df):
        """Analyze vulnerabilities by category"""
        if 'category' not in df.columns:
            return {}
        
        category_counts = df['category'].value_counts().to_dict()
        total = len(df)
        
        analysis = {}
        for category, count in category_counts.items():
            category_key = category.lower().replace(' ', '_').replace('-', '_')
            weight = self.category_weights.get(category_key, 1.0)
            
            analysis[category] = {
                'count': count,
                'percentage': (count / total * 100) if total > 0 else 0,
                'risk_weight': weight,
                'weighted_score': count * weight
            }
        
        return analysis
    
    def _calculate_risk_score(self, df, project_context):
        """Calculate overall risk score"""
        if len(df) == 0:
            return 0.0
        
        # Base score from severity
        severity_score = 0.0
        for _, vuln in df.iterrows():
            severity = vuln.get('severity', 'low')
            severity_score += self.severity_weights.get(severity, 1.0)
        
        # Normalize by number of vulnerabilities
        base_score = severity_score / len(df)
        
        # Apply context multipliers
        context_multiplier = 1.0
        
        # Project type multiplier
        if project_context.get('type') == 'web_application':
            context_multiplier *= 1.2
        elif project_context.get('type') == 'api':
            context_multiplier *= 1.1
        
        # Data sensitivity multiplier
        data_sensitivity = project_context.get('data_sensitivity', 'medium')
        if data_sensitivity == 'high':
            context_multiplier *= 1.3
        elif data_sensitivity == 'critical':
            context_multiplier *= 1.5
        
        # External exposure multiplier
        if project_context.get('external_facing', False):
            context_multiplier *= 1.2
        
        # Calculate final score (0-10 scale)
        final_score = min(10.0, base_score * context_multiplier)
        
        return round(final_score, 2)
    
    def _identify_priority_vulnerabilities(self, df):
        """Identify high-priority vulnerabilities"""
        if len(df) == 0:
            return []
        
        priority_vulns = []
        
        for _, vuln in df.iterrows():
            priority_score = 0.0
            
            # Severity contribution
            severity = vuln.get('severity', 'low')
            priority_score += self.severity_weights.get(severity, 1.0)
            
            # CVSS score contribution
            cvss_score = vuln.get('cvss_score', 0)
            if cvss_score > 0:
                priority_score += cvss_score
            
            # Exploitability contribution
            exploitability = vuln.get('exploitability', 'not_defined')
            if exploitability == 'functional':
                priority_score += 3.0
            elif exploitability == 'proof_of_concept':
                priority_score += 2.0
            elif exploitability == 'unproven':
                priority_score += 1.0
            
            # Category contribution
            category = vuln.get('category', '').lower().replace(' ', '_').replace('-', '_')
            category_weight = self.category_weights.get(category, 1.0)
            priority_score *= category_weight
            
            if priority_score >= 8.0:  # High priority threshold
                priority_vulns.append({
                    'id': vuln.get('id'),
                    'title': vuln.get('title'),
                    'severity': severity,
                    'priority_score': round(priority_score, 2),
                    'reason': self._get_priority_reason(vuln, priority_score)
                })
        
        # Sort by priority score
        priority_vulns.sort(key=lambda x: x['priority_score'], reverse=True)
        
        return priority_vulns[:10]  # Return top 10
    
    def _get_priority_reason(self, vuln, score):
        """Get reason for high priority"""
        reasons = []
        
        if vuln.get('severity') == 'critical':
            reasons.append('Critical severity')
        
        if vuln.get('cvss_score', 0) >= 9.0:
            reasons.append('High CVSS score')
        
        if vuln.get('exploitability') == 'functional':
            reasons.append('Functional exploit available')
        
        category = vuln.get('category', '').lower()
        if 'injection' in category:
            reasons.append('Injection vulnerability')
        
        return ', '.join(reasons) if reasons else 'High risk score'
    
    def _generate_recommendations(self, df, project_context):
        """Generate security recommendations"""
        recommendations = []
        
        if len(df) == 0:
            return ['Continue regular security scanning']
        
        # Severity-based recommendations
        critical_count = len(df[df['severity'] == 'critical']) if 'severity' in df.columns else 0
        high_count = len(df[df['severity'] == 'high']) if 'severity' in df.columns else 0
        
        if critical_count > 0:
            recommendations.append(f'Immediately address {critical_count} critical vulnerabilities')
        
        if high_count > 0:
            recommendations.append(f'Prioritize fixing {high_count} high severity vulnerabilities')
        
        # Category-based recommendations
        if 'category' in df.columns:
            categories = df['category'].value_counts()
            
            for category, count in categories.head(3).items():
                if 'injection' in category.lower():
                    recommendations.append('Implement input validation and parameterized queries')
                elif 'xss' in category.lower() or 'cross-site' in category.lower():
                    recommendations.append('Enable Content Security Policy and output encoding')
                elif 'authentication' in category.lower():
                    recommendations.append('Strengthen authentication mechanisms')
                elif 'access control' in category.lower():
                    recommendations.append('Review and implement proper access controls')
        
        # Context-based recommendations
        if project_context.get('external_facing', False):
            recommendations.append('Implement Web Application Firewall (WAF)')
        
        if project_context.get('data_sensitivity') in ['high', 'critical']:
            recommendations.append('Enable encryption for sensitive data')
        
        # General recommendations
        recommendations.extend([
            'Implement regular security scanning in CI/CD pipeline',
            'Conduct security code reviews',
            'Keep dependencies up to date',
            'Monitor for new vulnerabilities'
        ])
        
        return recommendations[:8]  # Return top 8 recommendations